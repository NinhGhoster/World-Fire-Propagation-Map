"""
Moving Firefighter Problem Data Loader and Analyzer

This module provides comprehensive functionality to load, analyze, and visualize 
Moving Firefighter Problem instances and solutions saved as JSON files.

Created for the Moving Firefighter Problem research project.
Compatible with JSON files generated by the moving_firefighter_example.ipynb notebook.

Author: Generated for Moving Firefighter Problem Analysis
Date: 2024
"""

import json
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import os
from typing import Dict, List, Tuple, Optional, Any
from datetime import datetime
import pandas as pd


class MovingFirefighterDataLoader:
    """
    Comprehensive loader and analyzer for Moving Firefighter Problem data.
    
    This class handles loading JSON files containing problem instances and solutions,
    provides detailed data structure descriptions, and offers visualization capabilities.
    """
    
    def __init__(self):
        """Initialize the data loader."""
        self.problem_data = None
        self.solution_data = None
        self.graph = None
        self.loaded_files = []
    
    def load_data(self, problem_file: str, solution_file: str = None) -> Dict[str, Any]:
        """
        Load Moving Firefighter Problem data from JSON files.
        
        Args:
            problem_file (str): Path to the problem JSON file
            solution_file (str, optional): Path to the solution JSON file
            
        Returns:
            Dict containing loaded data and metadata
            
        Raises:
            FileNotFoundError: If files don't exist
            json.JSONDecodeError: If files contain invalid JSON
        """
        print("ðŸ”„ Loading Moving Firefighter Problem data...")
        print("=" * 60)
        
        # Load problem data
        if not os.path.exists(problem_file):
            raise FileNotFoundError(f"Problem file not found: {problem_file}")
            
        with open(problem_file, 'r') as f:
            self.problem_data = json.load(f)
        
        print(f"âœ… Loaded problem from: {problem_file}")
        self._describe_problem_data()
        
        # Load solution data if provided
        self.solution_data = None
        if solution_file and os.path.exists(solution_file):
            with open(solution_file, 'r') as f:
                self.solution_data = json.load(f)
            print(f"âœ… Loaded solution from: {solution_file}")
            self._describe_solution_data()
        elif solution_file:
            print(f"âš ï¸  Solution file not found: {solution_file}")
        
        # Create graph object
        self._create_graph_object()
        
        # Store loaded file info
        self.loaded_files = [problem_file, solution_file] if solution_file else [problem_file]
        
        print("=" * 60)
        print("âœ… Data loading complete!")
        
        return {
            'problem': self.problem_data,
            'solution': self.solution_data,
            'graph': self.graph,
            'files': self.loaded_files
        }
    
    def _describe_problem_data(self):
        """Provide detailed description of the problem data structure."""
        print("\nðŸ“Š PROBLEM DATA STRUCTURE:")
        print("-" * 40)
        
        # Metadata section
        metadata = self.problem_data.get('metadata', {})
        print("ðŸ·ï¸  METADATA:")
        print(f"   â€¢ Created: {metadata.get('created_at', 'Unknown')}")
        print(f"   â€¢ Description: {metadata.get('description', 'N/A')}")
        print(f"   â€¢ Version: {metadata.get('version', 'N/A')}")
        
        # Parameters section
        params = self.problem_data.get('parameters', {})
        print("\nâš™ï¸  PROBLEM PARAMETERS:")
        print(f"   â€¢ Number of vertices (n): {params.get('n', 'N/A')}")
        print(f"   â€¢ Distance multiplier (Î»): {params.get('lambda_d', 'N/A')}")
        print(f"   â€¢ Initial burning nodes: {params.get('burnt_nodes', 'N/A')}")
        print(f"   â€¢ Problem instance ID: {params.get('instance', 'N/A')}")
        print(f"   â€¢ Spatial dimension: {params.get('dimension', 'N/A')}")
        print(f"   â€¢ Edge probability: {params.get('edge_probability', 'N/A'):.3f}")
        print(f"   â€¢ Defense rounds limit (D): {params.get('D', 'N/A')}")
        print(f"   â€¢ Burning rounds limit (B): {params.get('B', 'N/A')}")
        print(f"   â€¢ Random seed: {params.get('seed', 'N/A')}")
        
        # Graph structure section
        graph_data = self.problem_data.get('graph', {})
        print("\nðŸ”— GRAPH STRUCTURE:")
        print(f"   â€¢ Vertices: {graph_data.get('num_vertices', 'N/A')}")
        print(f"   â€¢ Edges: {graph_data.get('num_edges', 'N/A')}")
        print(f"   â€¢ Initially burning: {graph_data.get('burnt_nodes', [])}")
        
        adj_matrix = graph_data.get('adjacency_matrix', [])
        dist_matrix = graph_data.get('distance_matrix', [])
        coords = graph_data.get('coordinates', None)
        
        if adj_matrix:
            print(f"   â€¢ Adjacency matrix: {len(adj_matrix)}Ã—{len(adj_matrix[0])} shape")
            density = sum(sum(row) for row in adj_matrix) / (len(adj_matrix) * (len(adj_matrix) - 1))
            print(f"   â€¢ Graph density: {density:.3f}")
        
        if dist_matrix:
            print(f"   â€¢ Distance matrix: {len(dist_matrix)}Ã—{len(dist_matrix[0])} shape")
            max_dist = max(max(row) for row in dist_matrix)
            avg_dist = np.mean([d for row in dist_matrix for d in row if d > 0])
            print(f"   â€¢ Max travel time: {max_dist:.2f}")
            print(f"   â€¢ Average travel time: {avg_dist:.2f}")
        
        if coords:
            print(f"   â€¢ 3D coordinates available: {len(coords)} points")
    
    def _describe_solution_data(self):
        """Provide detailed description of the solution data structure."""
        if not self.solution_data:
            return
            
        print("\nðŸŽ¯ SOLUTION DATA STRUCTURE:")
        print("-" * 40)
        
        # Metadata section
        metadata = self.solution_data.get('metadata', {})
        print("ðŸ·ï¸  SOLUTION METADATA:")
        print(f"   â€¢ Created: {metadata.get('created_at', 'Unknown')}")
        print(f"   â€¢ Problem file: {metadata.get('problem_file', 'N/A')}")
        print(f"   â€¢ Solver used: {metadata.get('solver', 'N/A')}")
        print(f"   â€¢ Version: {metadata.get('version', 'N/A')}")
        
        # Solution details
        solution = self.solution_data.get('solution', {})
        print("\nðŸ”§ SOLUTION DETAILS:")
        print(f"   â€¢ Feasible: {solution.get('feasible', 'N/A')}")
        print(f"   â€¢ Objective value: {solution.get('objective', 'N/A')}")
        print(f"   â€¢ Runtime: {solution.get('runtime', 'N/A'):.2f} seconds" if solution.get('runtime') else "   â€¢ Runtime: N/A")
        print(f"   â€¢ Completed: {solution.get('not_interrupted', 'N/A')}")
        
        # Defense sequence analysis
        defense_seq = solution.get('defense_sequence', [])
        if defense_seq:
            print(f"\nðŸš’ FIREFIGHTER STRATEGY:")
            print(f"   â€¢ Defense sequence length: {len(defense_seq)}")
            
            # Extract path and defended vertices
            firefighter_path = [vertex for vertex, _, _ in defense_seq]
            defended_vertices = set(firefighter_path[1:])  # Exclude starting position
            
            print(f"   â€¢ Starting position: Vertex {firefighter_path[0] if firefighter_path else 'N/A'}")
            print(f"   â€¢ Unique vertices defended: {len(defended_vertices)}")
            print(f"   â€¢ Total defense actions: {len(defense_seq) - 1}")
            
            # Movement analysis
            movements = []
            for i in range(len(defense_seq) - 1):
                from_v = defense_seq[i][0]
                to_v = defense_seq[i + 1][0]
                if from_v != to_v:
                    movements.append((from_v, to_v))
            
            print(f"   â€¢ Actual movements: {len(movements)}")
            print(f"   â€¢ Reinforcements (staying put): {len(defense_seq) - 1 - len(movements)}")
            
            if movements:
                print(f"   â€¢ Movement path: {' â†’ '.join(str(m[0]) for m in movements[:3])}{'...' if len(movements) > 3 else ''}")
        
        # Analysis summary
        analysis = self.solution_data.get('analysis', {})
        print(f"\nðŸ“ˆ PERFORMANCE ANALYSIS:")
        print(f"   â€¢ Total vertices: {analysis.get('total_vertices', 'N/A')}")
        print(f"   â€¢ Initially burning: {analysis.get('initially_burning', 'N/A')}")
        print(f"   â€¢ Final burned: {analysis.get('final_burned', 'N/A')}")
        print(f"   â€¢ Vertices saved: {analysis.get('vertices_saved', 'N/A')}")
        print(f"   â€¢ Defended vertices: {analysis.get('defended_vertices', 'N/A')}")
        
        if analysis.get('total_vertices') and analysis.get('vertices_saved'):
            save_rate = (analysis['vertices_saved'] / analysis['total_vertices']) * 100
            print(f"   â€¢ Success rate: {save_rate:.1f}%")
    
    def _create_graph_object(self):
        """Create a graph object from loaded data for analysis."""
        if not self.problem_data:
            return
            
        graph_data = self.problem_data.get('graph', {})
        
        # Create simple namespace object to hold graph data
        import types
        self.graph = types.SimpleNamespace()
        
        # Convert back to numpy arrays
        self.graph.A = np.array(graph_data.get('adjacency_matrix', []))
        self.graph.D = np.array(graph_data.get('distance_matrix', []))
        self.graph.burnt_nodes = graph_data.get('burnt_nodes', [])
        
        if graph_data.get('coordinates'):
            self.graph.xyz = np.array(graph_data['coordinates'])
        
        print(f"\nðŸ”§ Recreated graph object:")
        print(f"   â€¢ Adjacency matrix: {self.graph.A.shape}")
        print(f"   â€¢ Distance matrix: {self.graph.D.shape}")
        print(f"   â€¢ Burnt nodes: {self.graph.burnt_nodes}")
    
    def get_data_summary(self) -> Dict[str, Any]:
        """
        Get a comprehensive summary of the loaded data.
        
        Returns:
            Dictionary containing summary statistics and key information
        """
        if not self.problem_data:
            return {"error": "No data loaded"}
        
        params = self.problem_data.get('parameters', {})
        graph_data = self.problem_data.get('graph', {})
        
        summary = {
            "problem_info": {
                "vertices": params.get('n'),
                "initial_fires": len(graph_data.get('burnt_nodes', [])),
                "lambda": params.get('lambda_d'),
                "defense_limit": params.get('D'),
                "burning_limit": params.get('B'),
                "edge_probability": params.get('edge_probability'),
                "graph_density": self._calculate_graph_density()
            }
        }
        
        if self.solution_data:
            solution = self.solution_data.get('solution', {})
            analysis = self.solution_data.get('analysis', {})
            
            summary["solution_info"] = {
                "feasible": solution.get('feasible'),
                "objective": solution.get('objective'),
                "runtime": solution.get('runtime'),
                "vertices_saved": analysis.get('vertices_saved'),
                "success_rate": (analysis.get('vertices_saved', 0) / analysis.get('total_vertices', 1)) * 100,
                "defended_vertices": analysis.get('defended_vertices')
            }
            
            # Analyze defense strategy
            defense_seq = solution.get('defense_sequence', [])
            if defense_seq:
                summary["strategy_info"] = self._analyze_defense_strategy(defense_seq)
        
        return summary
    
    def _calculate_graph_density(self) -> float:
        """Calculate the density of the graph."""
        if not hasattr(self.graph, 'A') or self.graph.A.size == 0:
            return 0.0
        
        n = self.graph.A.shape[0]
        if n <= 1:
            return 0.0
        
        num_edges = np.sum(self.graph.A) / 2  # Undirected graph
        max_edges = n * (n - 1) / 2
        return num_edges / max_edges if max_edges > 0 else 0.0
    
    def _analyze_defense_strategy(self, defense_sequence: List[Tuple]) -> Dict[str, Any]:
        """Analyze the firefighter's defense strategy."""
        if not defense_sequence:
            return {}
        
        # Extract firefighter path
        path = [vertex for vertex, _, _ in defense_sequence]
        
        # Count movements vs reinforcements
        movements = 0
        reinforcements = 0
        
        for i in range(1, len(path)):
            if path[i] != path[i-1]:
                movements += 1
            else:
                reinforcements += 1
        
        # Calculate travel distances
        total_travel_distance = 0.0
        if hasattr(self.graph, 'D') and self.graph.D.size > 0:
            for i in range(1, len(path)):
                if path[i] != path[i-1]:  # Only count actual movements
                    total_travel_distance += self.graph.D[path[i-1], path[i]]
        
        return {
            "total_actions": len(defense_sequence) - 1,
            "movements": movements,
            "reinforcements": reinforcements,
            "unique_positions": len(set(path)),
            "total_travel_distance": total_travel_distance,
            "avg_travel_distance": total_travel_distance / movements if movements > 0 else 0.0,
            "mobility_ratio": movements / (len(defense_sequence) - 1) if len(defense_sequence) > 1 else 0.0
        }
    
    def visualize_problem(self, figsize: Tuple[int, int] = (12, 8), save_path: str = None):
        """
        Create comprehensive visualization of the loaded problem and solution.
        
        Args:
            figsize: Figure size for matplotlib
            save_path: Optional path to save the visualization
        """
        if not self.problem_data or not self.graph:
            print("âŒ No data loaded for visualization")
            return
        
        params = self.problem_data.get('parameters', {})
        n = params.get('n', 0)
        
        if n == 0:
            print("âŒ Invalid graph size")
            return
        
        # Create NetworkX graph
        G = nx.Graph()
        for i in range(n):
            G.add_node(i)
        
        # Add edges from adjacency matrix
        for i in range(n):
            for j in range(i+1, n):
                if self.graph.A[i, j] == 1:
                    G.add_edge(i, j)
        
        # Create visualization
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        fig.suptitle(f'Moving Firefighter Problem Analysis\nLoaded from: {os.path.basename(self.loaded_files[0])}', 
                     fontsize=14, fontweight='bold')
        
        # Plot 1: Initial state
        ax1 = axes[0, 0]
        pos = nx.spring_layout(G, seed=42)
        
        node_colors = ['red' if i in self.graph.burnt_nodes else 'lightgray' for i in range(n)]
        nx.draw(G, pos, ax=ax1, node_color=node_colors, with_labels=True, 
                node_size=500, font_size=10, font_weight='bold')
        ax1.set_title('Initial Problem State')
        ax1.text(0.02, 0.98, f'n={n}, Î»={params.get("lambda_d", "?")}', 
                transform=ax1.transAxes, verticalalignment='top', 
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        # Plot 2: Distance matrix heatmap
        ax2 = axes[0, 1]
        if hasattr(self.graph, 'D') and self.graph.D.size > 0:
            im = ax2.imshow(self.graph.D, cmap='viridis', interpolation='nearest')
            ax2.set_title('Distance Matrix')
            ax2.set_xlabel('Destination Vertex')
            ax2.set_ylabel('Source Vertex')
            plt.colorbar(im, ax=ax2, label='Travel Time')
        else:
            ax2.text(0.5, 0.5, 'No Distance Matrix', ha='center', va='center', transform=ax2.transAxes)
            ax2.set_title('Distance Matrix (N/A)')
        
        # Plot 3: Solution visualization (if available)
        ax3 = axes[1, 0]
        if self.solution_data:
            solution = self.solution_data.get('solution', {})
            defense_seq = solution.get('defense_sequence', [])
            
            if defense_seq:
                # Show firefighter path
                path = [vertex for vertex, _, _ in defense_seq]
                defended_vertices = set(path[1:])
                
                node_colors = []
                for i in range(n):
                    if i in self.graph.burnt_nodes:
                        node_colors.append('darkred')
                    elif i in defended_vertices:
                        node_colors.append('green')
                    else:
                        node_colors.append('lightblue')
                
                nx.draw(G, pos, ax=ax3, node_color=node_colors, with_labels=True,
                        node_size=500, font_size=10, font_weight='bold')
                
                # Draw firefighter path
                path_edges = [(path[i], path[i+1]) for i in range(len(path)-1) if path[i] != path[i+1]]
                if path_edges:
                    nx.draw_networkx_edges(G, pos, edgelist=path_edges, ax=ax3,
                                         edge_color='blue', width=3, alpha=0.7)
                
                ax3.set_title('Solution Strategy')
                objective = solution.get('objective', 'N/A')
                runtime = solution.get('runtime', 'N/A')
                ax3.text(0.02, 0.98, f'Burned: {objective}\nTime: {runtime:.1f}s' if isinstance(runtime, (int, float)) else f'Burned: {objective}', 
                        transform=ax3.transAxes, verticalalignment='top',
                        bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.8))
            else:
                ax3.text(0.5, 0.5, 'No Solution Available', ha='center', va='center', transform=ax3.transAxes)
                ax3.set_title('Solution (N/A)')
        else:
            ax3.text(0.5, 0.5, 'No Solution Loaded', ha='center', va='center', transform=ax3.transAxes)
            ax3.set_title('Solution (Not Loaded)')
        
        # Plot 4: Summary statistics
        ax4 = axes[1, 1]
        ax4.axis('off')
        
        summary = self.get_data_summary()
        prob_info = summary.get('problem_info', {})
        sol_info = summary.get('solution_info', {})
        
        stats_text = f"""PROBLEM STATISTICS:
â€¢ Vertices: {prob_info.get('vertices', 'N/A')}
â€¢ Initial Fires: {prob_info.get('initial_fires', 'N/A')}
â€¢ Distance Multiplier: {prob_info.get('lambda', 'N/A')}
â€¢ Graph Density: {prob_info.get('graph_density', 0):.3f}

SOLUTION STATISTICS:"""
        
        if sol_info:
            stats_text += f"""
â€¢ Feasible: {sol_info.get('feasible', 'N/A')}
â€¢ Success Rate: {sol_info.get('success_rate', 0):.1f}%
â€¢ Runtime: {sol_info.get('runtime', 'N/A'):.1f}s""" if isinstance(sol_info.get('runtime'), (int, float)) else f"""
â€¢ Feasible: {sol_info.get('feasible', 'N/A')}
â€¢ Success Rate: {sol_info.get('success_rate', 0):.1f}%"""
        else:
            stats_text += "\nâ€¢ No solution data"
        
        ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, verticalalignment='top',
                fontfamily='monospace', fontsize=10,
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"ðŸ’¾ Visualization saved to: {save_path}")
        
        plt.show()
    
    def export_to_dataframe(self) -> pd.DataFrame:
        """
        Export the loaded data to a pandas DataFrame for analysis.
        
        Returns:
            DataFrame with problem and solution data
        """
        if not self.problem_data:
            return pd.DataFrame()
        
        summary = self.get_data_summary()
        
        # Flatten the summary data
        flattened_data = {}
        
        # Add problem info
        prob_info = summary.get('problem_info', {})
        for key, value in prob_info.items():
            flattened_data[f'problem_{key}'] = value
        
        # Add solution info if available
        sol_info = summary.get('solution_info', {})
        for key, value in sol_info.items():
            flattened_data[f'solution_{key}'] = value
        
        # Add strategy info if available
        strat_info = summary.get('strategy_info', {})
        for key, value in strat_info.items():
            flattened_data[f'strategy_{key}'] = value
        
        # Add metadata
        metadata = self.problem_data.get('metadata', {})
        flattened_data['created_at'] = metadata.get('created_at')
        flattened_data['problem_file'] = self.loaded_files[0] if self.loaded_files else None
        
        return pd.DataFrame([flattened_data])


def load_multiple_instances(file_pattern: str, directory: str = ".") -> List[MovingFirefighterDataLoader]:
    """
    Load multiple Moving Firefighter Problem instances from a directory.
    
    Args:
        file_pattern: Pattern to match problem files (e.g., "mfp_*_problem.json")
        directory: Directory to search in
        
    Returns:
        List of MovingFirefighterDataLoader objects
    """
    import glob
    
    problem_files = glob.glob(os.path.join(directory, file_pattern))
    loaders = []
    
    print(f"ðŸ” Found {len(problem_files)} problem files matching pattern: {file_pattern}")
    
    for problem_file in sorted(problem_files):
        # Try to find corresponding solution file
        solution_file = problem_file.replace('_problem.json', '_solution.json')
        
        try:
            loader = MovingFirefighterDataLoader()
            loader.load_data(problem_file, solution_file if os.path.exists(solution_file) else None)
            loaders.append(loader)
        except Exception as e:
            print(f"âš ï¸  Failed to load {problem_file}: {e}")
    
    return loaders


def create_comparative_analysis(loaders: List[MovingFirefighterDataLoader], save_path: str = None) -> pd.DataFrame:
    """
    Create comparative analysis of multiple Moving Firefighter Problem instances.
    
    Args:
        loaders: List of MovingFirefighterDataLoader objects
        save_path: Optional path to save the analysis
        
    Returns:
        DataFrame with comparative analysis
    """
    if not loaders:
        print("âŒ No loaders provided for analysis")
        return pd.DataFrame()
    
    print(f"ðŸ“Š Creating comparative analysis of {len(loaders)} instances...")
    
    # Collect all data
    all_data = []
    for i, loader in enumerate(loaders):
        df = loader.export_to_dataframe()
        if not df.empty:
            df['instance_id'] = i
            all_data.append(df)
    
    if not all_data:
        print("âŒ No valid data found in loaders")
        return pd.DataFrame()
    
    # Combine all data
    combined_df = pd.concat(all_data, ignore_index=True)
    
    # Create summary statistics
    print("\nðŸ“ˆ COMPARATIVE ANALYSIS SUMMARY:")
    print("=" * 50)
    
    numeric_columns = combined_df.select_dtypes(include=[np.number]).columns
    if len(numeric_columns) > 0:
        print("\nNUMERIC STATISTICS:")
        print(combined_df[numeric_columns].describe())
    
    # Success rate analysis
    if 'solution_success_rate' in combined_df.columns:
        print(f"\nSUCCESS RATE ANALYSIS:")
        print(f"â€¢ Average success rate: {combined_df['solution_success_rate'].mean():.2f}%")
        print(f"â€¢ Best performance: {combined_df['solution_success_rate'].max():.2f}%")
        print(f"â€¢ Worst performance: {combined_df['solution_success_rate'].min():.2f}%")
    
    # Runtime analysis
    if 'solution_runtime' in combined_df.columns:
        print(f"\nRUNTIME ANALYSIS:")
        print(f"â€¢ Average runtime: {combined_df['solution_runtime'].mean():.2f}s")
        print(f"â€¢ Fastest solve: {combined_df['solution_runtime'].min():.2f}s")
        print(f"â€¢ Slowest solve: {combined_df['solution_runtime'].max():.2f}s")
    
    if save_path:
        combined_df.to_csv(save_path, index=False)
        print(f"\nðŸ’¾ Analysis saved to: {save_path}")
    
    return combined_df


# Example usage and demonstration
if __name__ == "__main__":
    print("ðŸ”¥ Moving Firefighter Problem Data Loader")
    print("=" * 60)
    print("This module provides comprehensive functionality for loading and analyzing")
    print("Moving Firefighter Problem data saved as JSON files.")
    print()
    print("EXAMPLE USAGE:")
    print()
    print("# Load single instance")
    print("loader = MovingFirefighterDataLoader()")
    print("data = loader.load_data('problem.json', 'solution.json')")
    print()
    print("# Get summary")
    print("summary = loader.get_data_summary()")
    print("print(summary)")
    print()
    print("# Visualize")
    print("loader.visualize_problem(save_path='analysis.png')")
    print()
    print("# Export to DataFrame")
    print("df = loader.export_to_dataframe()")
    print()
    print("# Load multiple instances")
    print("loaders = load_multiple_instances('mfp_*_problem.json')")
    print("analysis_df = create_comparative_analysis(loaders)") 